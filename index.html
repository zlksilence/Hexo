<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="silence">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="silence">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="silence">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>silence</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">silence</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/Structed-Streaming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/19/Structed-Streaming/" class="post-title-link" itemprop="url">Structed Streaming学习</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-19 17:38:48" itemprop="dateCreated datePublished" datetime="2019-07-19T17:38:48+08:00">2019-07-19</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此篇主要记录自己在项目中学习使用Structed Streaming过程中遇到的问题及解决办法, 学习时间不长,不到一周,为了项目临时写的,仅供参考。关于Structured Streaming的全面介绍参考</p>
<h2 id="Structed-Streraming-介绍"><a href="#Structed-Streraming-介绍" class="headerlink" title="Structed Streraming 介绍"></a>Structed Streraming 介绍</h2><p>​        从Spark2.0之后,Spark Streaming开始引入一种新的流式引擎:Structed Streaming 。开发这套API的主要动因是自Spark 2.0之后，以RDD为核心的API逐步升级到Dataset/DataFrame上，而另一方面，以RDD为基础的编程模型对开发人员的要求较高，需要有足够的编程背景才能胜任Spark Streaming的编程工作，而新引入的Structured Streaming模型是把数据流当作一个没有边界的数据表来对待，这样开发人员可以在流上使用Spark SQL进行流处理，这大大降低了流计算的编程门槛。原理上看，Structed Streaming还是一个微批处理模型，数据流作为一系列小批量作业处理，从而实现低至100毫秒的端到端延迟和完全一次的容错保证。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>​    一个Structed Streraming 程序运行大致分为:</p>
<ol>
<li>创建Spark Session</li>
<li>创建流式DataFrame源</li>
<li>定义一系列流式操作</li>
<li>创建DataFrame的输出模式</li>
<li>开始流式处理</li>
</ol>
<p>​    简单的处理程序Java示例单词统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.streaming.StreamingQuery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">// 1. 首先必须建立Sparksession. 这和Spark Streaming创建使用SparkSession类似，在Spark　Streaming中若要使用Hive，则开启 .enableHiveSupport()</span></span><br><span class="line">SparkSession spark = SparkSession</span><br><span class="line">  .builder()</span><br><span class="line">  .appName(<span class="string">"JavaStructuredNetworkWordCount"</span>)</span><br><span class="line">  .getOrCreate();</span><br><span class="line"><span class="comment">//　2. 创建一个流式的DataFrame 这里是从一个网络socket创建 其他也接受Kafka等</span></span><br><span class="line"><span class="comment">// Create DataFrame representing the stream of input lines from connection to localhost:9999</span></span><br><span class="line">Dataset&lt;Row&gt; lines = spark</span><br><span class="line">  .readStream()</span><br><span class="line">  .format(<span class="string">"socket"</span>)</span><br><span class="line">  .option(<span class="string">"host"</span>, <span class="string">"localhost"</span>)</span><br><span class="line">  .option(<span class="string">"port"</span>, <span class="number">9999</span>)</span><br><span class="line">  .load();</span><br><span class="line"><span class="comment">// 3. Split the lines into words</span></span><br><span class="line">Dataset&lt;String&gt; words = lines</span><br><span class="line">  .as(Encoders.STRING())</span><br><span class="line">  .flatMap((FlatMapFunction&lt;String, String&gt;) x -&gt; Arrays.asList(x.split(<span class="string">" "</span>)).iterator(), Encoders.STRING());</span><br><span class="line"><span class="comment">// Generate running word count</span></span><br><span class="line">Dataset&lt;Row&gt; wordCounts = words.groupBy(<span class="string">"value"</span>).count();</span><br><span class="line"><span class="comment">// 4. 5. Start running the query that prints the running counts to the console</span></span><br><span class="line"><span class="comment">// 输出模式后续会讲，这里是输出到控制台</span></span><br><span class="line"><span class="comment">// 这里的Start类似与spark里的action操作,有start()才会真正的开始流式操作</span></span><br><span class="line">StreamingQuery query = wordCounts.writeStream()</span><br><span class="line">  .outputMode(<span class="string">"complete"</span>)</span><br><span class="line">  .format(<span class="string">"console"</span>)</span><br><span class="line">  .start();</span><br><span class="line"><span class="comment">// 这里必须阻塞等待程序执行完成,不然程序会直接结束</span></span><br><span class="line">query.awaitTermination();</span><br></pre></td></tr></table></figure>

<p>程序在本地跑(往socket发送数据后)可以看到:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TERMINAL 2: RUNNING JavaStructuredNetworkWordCount</span></span><br><span class="line">$ ./bin/run-example org.apache.spark.examples.sql.streaming.JavaStructuredNetworkWordCount localhost 9999</span><br><span class="line">-------------------------------------------</span><br><span class="line">Batch: 0</span><br><span class="line">-------------------------------------------</span><br><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache|    1|</span><br><span class="line">| spark|    1|</span><br><span class="line">+------+-----+</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Batch: 1</span><br><span class="line">-------------------------------------------</span><br><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache|    2|</span><br><span class="line">| spark|    1|</span><br><span class="line">|hadoop|    1|</span><br><span class="line">+------+-----+</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​    以上就是一个简单的单词统计操作程序示例,要了解其中更相信的运行原理参看后续章节.</p>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>结构化流中的关键思想是将实时数据流视为连续追加的表。这导致新的流处理模型非常类似于批处理模型。您将流式计算表示为静态表上的标准批处理查询，Spark将其作为<em>无界</em>输入表上的<em>增量</em>查询运行。</p>
<p><img src="/imag%5CSpark%5Cstructured-streaming-stream-as-a-table.png" alt></p>
<p>将数据流始为“输入表”，到达流的每个数据项都像一个新行被附加到输入表（当然也可以不新加而是更新表中的数据，比如聚合操作）。</p>
<p>还可以定义触发间隔 trigger interva，每个 trigger interva将使新行追加到结果表中，结果表一旦有更新，则会根据输出模式output mode输出到外部Sink（Sink，相当外部的数据源）。</p>
<p><img src="/imag%5CSpark%5Cstructured-streaming-model.png" alt></p>
<p>​    Output Mode：输出模式告诉我们如何将<strong>结果表</strong>输出，上述单词统计输出就指定了“complete”，实际还可以有其他模式包括“append”、“<em>Update</em>”，这几个好理解，结果表那么大，输出模式告诉程序是将<strong>全部结果都输出</strong>，还是只<strong>输出新加的</strong>，还是<strong>输出更新过的</strong>。</p>
<p>​    Output Sinks：就是外部数据源，<strong>结果表</strong>一开始都是存在内存中，我们定义好了输出模式，另一部分就是定义结果数据输出到哪里。上述单词统计就是输出到了控制台，着方便于我们查看和调试，其他Sink包括：</p>
<ol>
<li><p><strong>File sink</strong> - 输出到文件 HDFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">writeStream</span><br><span class="line">    .format(<span class="string">"parquet"</span>)        <span class="comment">// can be "orc", "json", "csv", etc.</span></span><br><span class="line">    .option(<span class="string">"path"</span>, <span class="string">"path/to/destination/dir"</span>)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Kafka sink</strong> - 输出到Kafka</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writeStream</span><br><span class="line">    .format(<span class="string">"kafka"</span>)</span><br><span class="line">    .option(<span class="string">"kafka.bootstrap.servers"</span>, <span class="string">"host1:port1,host2:port2"</span>)</span><br><span class="line">    .option(<span class="string">"topic"</span>, <span class="string">"updates"</span>)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Foreach sink</strong> - 自定义输出，通过继承ForeachWriter实现其内部方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writeStream</span><br><span class="line">    .foreach(<span class="keyword">new</span> ForeachWriter()&#123;...&#125;)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Console sink (for debugging)</strong> - 控制台仅为调试.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writeStream</span><br><span class="line">    .format(<span class="string">"console"</span>)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure>

<p>单词统计流程示例：</p>
<p><img src="/imag%5CSpark%5Cstructured-streaming-example-model.png" alt></p>
<p>疑问：**随着程序运行，那结果表岂不越来越大？</p>
<p>​    它从流数据源读取最新的可用数据，逐步处理以更新结果，然后丢弃源数据。它仅保留更新结果所需的最小中间<em>状态</em>数据（例如，前面示例中的中间计数）。结果表，确实是逐步增大，但这只是针对输出模式“complete”。若是“append”，那么老旧数据就可以不要了，这样结果表就不会逐步增大了。一般使用“complete”，都是我们使用了聚合GroupBy等操作，这操作都是和应用有关，如单词统计，统计所有单词出现的数量，这里我们必须输出流上的全部的结果。</p>
<h3 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h3><p>​    Structured Streraming 都是使用DataFrane处理数据，但这里的DataFrame沿用和Spark Streaming下一样的类，<strong>并不意味着里面的方法都能是使用</strong>。在示例程序中我们使用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; lineas;</span><br><span class="line">lines.flatmap(...);</span><br><span class="line">lines.groupBy(...);</span><br></pre></td></tr></table></figure>

<p>​    这在Structed Streaming下是支持的，但若要使用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; lineas;</span><br><span class="line">lines.count();</span><br><span class="line">lines.foreach();</span><br><span class="line">lines.show();</span><br></pre></td></tr></table></figure>

<p>​    则会报错“ <code>AnalysisException</code> ”,明白这个是<strong>很重要的！！！！</strong>。我第一次跑就是因为文档没看完，用了show()导致程序运行不起来。。。</p>
<p>​    <strong>再次强调一下，流式DataFrame不支持一下操作：</strong></p>
<ul>
<li><code>流数据集尚不支持多个流聚合（即流式DF上的聚合链）。</code></li>
<li><code>流数据集不支持限制和前N行。</code></li>
<li><code>不支持对流数据集进行不同的操作。</code></li>
<li><code>仅在聚合和完全输出模式之后，流数据集才支持排序操作。</code></li>
<li><code>不支持流数据集上的几种外连接类型</code></li>
</ul>
<p>###外部输出Sink</p>
<p>​    这里重点说下Foreach sink，其他file sink和kafka sink好理解。Foreachsink是支持我们自定义的一个Sink，当我们想要输出到其他非kafka或文件源中，我们就可以继承它，实现里面的方法，然后我就可以自定义输出到外部源里面去了，如Mysql（Structured Streraming未原生支持JDBC的Sink）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">streamingDatasetOfString.writeStream().foreach(</span><br><span class="line">  <span class="keyword">new</span> ForeachWriter[String] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(<span class="keyword">long</span> partitionId, <span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Open connection 这里一般写数据库的连接操作，使用连接池，这里就是获取connection</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String record)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Write string to connection 每次会传入一行记录，这里用于执行 insert/update 语句</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Throwable errorOrNull)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Close the connection 使用完关闭连接 errorOrNull为process看到的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>​    当然只知道是不行的，我们还需知道具体在底层它是怎么实现，怎么调用的，<strong>程序内部实现</strong>如下：</p>
<pre><code>1. 每个分区**实例化一次**ForeachWriter
2. 对象必须**可序列化**
3. 方法的生命周期：对于partition_id的每个分区：
- 对于epoch_id的流数据的每个批次：
  - 方法open（partitionId，epochId）被调用。
  - 如果open（...）返回true，则对于分区和批处理中的每一行，将调用方法process（）。
  - 调用方法close（error），在处理行时看到错误（如果有的话）。
4. 如果open（）方法存在并且成功返回（不管返回值），则调用close（）方法（如果存在）</code></pre><p>​    前面已经说了几种支持的SInk，这里强调一下，<strong>一个流只能有一个外部输出Sink</strong>。这样写是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">writeStream</span><br><span class="line">    .format(<span class="string">"parquet"</span>)        <span class="comment">// can be "orc", "json", "csv", etc.</span></span><br><span class="line">    .option(<span class="string">"path"</span>, <span class="string">"path/to/destination/dir"</span>)</span><br><span class="line">    .format(<span class="string">"kafka"</span>)</span><br><span class="line">    .option(<span class="string">"kafka.bootstrap.servers"</span>, <span class="string">"host1:port1,host2:port2"</span>)</span><br><span class="line">    .option(<span class="string">"topic"</span>, <span class="string">"updates"</span>)</span><br><span class="line">    .start() <span class="comment">//程序只会执行第二个外部Sink</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​    PS：个人认为这是不好的设计，接触的那个项目需要用到一个流数据输出到两个或多个数据库（<a href="https://stackoverflow.com/questions/46295205/how-to-read-streaming-dataset-once-and-output-to-multiple-sinks" target="_blank" rel="noopener">参见</a>），这样不支持多个外部Sink导致只能设计成多个流去处理输出（当然可使用自定义foreach，在里面将数据存储到多个数据库）。在Spark Streaming可以使用cache()缓存中间计算结果，然后再定义多个外部输出的通道，但在Structured Streaming还<a href="https://issues.apache.org/jira/browse/SPARK-20927" target="_blank" rel="noopener">未支持cache()</a>，设计多个流去输出感觉有点浪费资源。当然也可能后续会支持多个外部输出的Sink，希望赶紧出来的吧。</p>
</blockquote>
<p>​    Spark 2.4 中已有<a href="https://docs.databricks.com/spark/latest/structured-streaming/foreach.html#reuse-existing-batch-data-sources-with-foreachbatch" target="_blank" rel="noopener">foreachBatch</a>方法，这方法可以实现多个外部数据输出了！！</p>
<h2 id="问题及解决办法"><a href="#问题及解决办法" class="headerlink" title="问题及解决办法"></a>问题及解决办法</h2><p><em>问题1 <a href="https://stackoverflow.com/questions/53963727/how-to-insert-spark-structured-streaming-dataframe-to-hive-external-table-locati" target="_blank" rel="noopener">如何输出到Hive</a>？</em></p>
<p>​    Structured Streaming 现在还未原生支持Hive Sink，不过有其他的解决方法。我项目中为了实现输出到Hive，实现三种解决方案：</p>
<ul>
<li><p><strong>使用Hive的Jdbc</strong>。在ForeachWriter中，用jdbc连接hive实现数据的存入。</p>
</li>
<li><p>使用File Sink。直接把数据输出到Hive的warhous下，tablename的表存储空间。即把数据文件直接放到Hive仓库表空间下。这样会遇到Hive无法识别出里面的数据，我在使用中发现，跑一次程序存下的数据，Hive无法查询出来，但在跑第二次程序时，之前的数据竟然都能用Hive查出来了，新存数据也能查出来。</p>
<p>我认为原因是Hive元数据库里，有记录每张表是否有数据，还有是有哪些分区的记录，因为我是直接放数据的，未经过Hive元数据库仓库，所以第一次Hive认为没有数据的。第二次跑时，spark 更新了一下元数据信息（可能是扫描Hive仓库下的数据来更新元数据信息），所以能查出数据了。</p>
<p>所以<strong>最终解决方案</strong>：<strong>程序正常通过File Sink把数据直接放入Hive 表空间下，然后程序外部单独跑个线程定时执行sparkSesson.sql(“create table ifnot exist…”)来更新元数据信息。</strong>这样只是我实现方法，未见其他地方有这样使用的，截至目前测试程序良好，未见错误。</p>
</li>
<li><p>等待官方更新添加Hive支持。。。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/ConCurrentHashMap源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/27/ConCurrentHashMap源码分析/" class="post-title-link" itemprop="url">ConCurrentHashMap 源码分析</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-27 10:00:00" itemprop="dateCreated datePublished" datetime="2019-06-27T10:00:00+08:00">2019-06-27</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-15 10:11:15" itemprop="dateModified" datetime="2019-07-15T10:11:15+08:00">2019-07-15</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    ConcurrentHashMap 是java内提供的一个线程安全的HashMap集合，多用于多线程中，单程线中性能不及HashMap。HashMap源码相对于ConCurrentHashMap较为简单，即一个hash桶，根据key的hash计算相对位置，有冲突采用<strong>链式/红黑树</strong>处理。ConCurrentHashMap复杂些，其主要使用分段加锁技术来保证读取和写入的高高性能。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>​    java并发相关关键字，主要保证内存数据的可见性，一个线程对此变量的修改能够及时被其他线程看到。实现原理即每次线程读取此变量都将从内存中读取，写入也及时写回内存。此关键字也能防止指令重排。详情参见：java内存模型 </p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>​    CAS（ComparaAndSwap）,现代处理器为并行处理提供的一个优化指令，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。其实CPU级别提供的一个原子指令，不用加锁，效率更高。</p>
<p>###java 对于CAS的实现</p>
<p>​    java中 <strong>sun.misc.Unsafe</strong> 实现了此方法，此类也在JUC（java.util.current）中如actomic类 大量使用，但官方不建议用户使用 sun.misc.Unsafe。因为 sun.misc.Unsafe 提供了可随意查看和修改JVM运行时的数据结构，使用举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">...</span><br><span class="line">Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">U = sun.misc.Unsafe U;</span><br><span class="line">SIZECTL = U.objectFieldOffset(k.getDeclaredField(<span class="string">"sizeCtl"</span>)); <span class="comment">// 获取字段在此类的偏移位置</span></span><br><span class="line">U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>); <span class="comment">// 将字段sizeCtl值通过CAS变成 -1</span></span><br></pre></td></tr></table></figure>

<p>Concurrent使用CAS主要是保证 volatile 变量在多线程中赋值的安全。</p>
<p>###ConcurrentHashMap中 CAS的应用</p>
<p>​    ConcurrentHashMap在1.8中通过使用 CAS与synchronized 来保证线程安全，完全不同于1.7中的分段加锁。使用CAS 保证了并发下加锁粒度变小。在1.8中，ConcurrentHashMap访问tab数组元素都是通过以下三个原子性的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子获取tab 上位置i下的Node  此方法直接从内存中读取，保证了获取Node的内存可见性</span></span><br><span class="line"><span class="comment">// 虽然tab是被 volatile 修饰，能保证 tab的可见性，但不能保证tab数组元素的可见性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CAS原子操作，为了给某个位置上的Node赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接对某个位置赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="读Get"><a href="#读Get" class="headerlink" title="读Get"></a>读Get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    读取流程和HashMap一直，直接访问数组相对位置的元素，判断是空没值还是链表或者是红黑树。COncurrentHashMap也是通过链表或红黑树存储冲突的元素。此操作未使用加锁。有一点需要注意，tab数组元素并不是想HashMap都是有效带有存储数据的，Concurrent包含三种Node：1. 正常带有k-v的 元素，node的hash即是k的hash 大于0；2. 不携带数据，node的hash小于0，这是标志着此处后面是用红黑树存储的冲突元素；3. null值；</p>
<p>###写Put</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">// 循环保证初始化或扩容仍能继续进行插入操作</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// 初始化数组空间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// bin即插入的为null，代表没有冲突直接CAS插入</span></span><br><span class="line">            <span class="comment">// CAS失败，意味着其他线程也在此位置插入了，则下次循环进行链表的插入；CAS成功则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 节点hash=1 则表示正在扩容</span></span><br><span class="line">            <span class="comment">// 如果在其他线程在扩容，则本线程去帮助扩容，扩容后下次循环进行正常插入</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这时代表 链表或红黑树的插入 需要对头元素加锁 </span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>; <span class="comment">// 如果有旧值的话，记录旧值</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 再次判断防止其他线程修改</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 大于0即代表是链表</span></span><br><span class="line">                        binCount = <span class="number">1</span>; <span class="comment">// 统计此表的大小</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">// 参数 ture 表示仅仅在有缺的情况下新增 不允许更新</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 这时是红黑树 已加锁 因此插入过程为一般红黑树插入</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 若链表长度大于8，则转化为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) <span class="comment">// 有旧值，map中没有新增元素 直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个map有新元素加入 所以增加其大小</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在对有冲突的链表或红黑树树插入时都需要使用synchronized 对头元素加锁，其他情形不需要加锁，因此效率很高。1.7中分段加锁效率不如1.8. 。</p>
<p>​    上述put操作中包含三个重要的函数：initTable()初始化数组空间；helpTransfer()帮助扩容；addCount()节点数增加；三个函数涉及多线程环境因此较为复杂，解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;  <span class="comment">// sizeCtl 默认16 或 用户设置初始容量</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) <span class="comment">// 判断时候有其他线程正在初始化</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">//CAS竞争</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">// 再次判断，防止其他线程已初始化tab</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY; </span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 即原空间的0.75，因此初始都是0.75的负载</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    sizeCtl 重要的控制变量，被volatile修饰。若此变量小于0，则表示其他线程正在执行初始化过程，此线程将放弃此次的cpu时间；若不小于0，则首先通过CAS竞争置变量为-1，竞争到则进行扩容，否则继续下此循环直至数组已初始化完成。</p>
<p>###计数器</p>
<p>​    计数器指的是Map是如何进行大小统计的，包含size()、addCount()、fullAddCount()三个 重要函数。多线程中一般使用AtomicLong来更新计数器，但在1.8之后新增了LongAdder来计数。两者之间最大不同在于，AtomicLong使用cas多个线程更新一个值，高并发下非常占用cpu资源，而LongAdder高并发下通过CountCell来使每个线程更细自己的Cell减少了竞争。ConcurrentHashMap就是使用类似LongAdder实现计数的。如下图所示，当低并发下多个线程通过CAS更新value，高并发下每个线程有自己cell变量，value通过计算所有的cell和来计数。</p>
<p><img src="/imag%5Cjava%5Clongaddr.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended); <span class="comment">// 函数里面死循环直至通过CAS更新了cell</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>​    扩容部分代码过于复杂，大致算法是将原表拆分，每个线程处理自己的区间（默认16个长度，通过特殊的ForwardingNode标识此桶正在扩容）。每个线程内进行自己的扩容时过程类似于HashMap。这样划分区间，可以使其他线程在检测到Map正在扩容时主动去帮助扩容（helpTransfer）。源码扩容部分以后再做分析～</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/java并发编程实践（三）-锁机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/java并发编程实践（三）-锁机制/" class="post-title-link" itemprop="url">java并发编程实践（三）-锁机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:20:30" itemprop="dateCreated datePublished" datetime="2019-06-24T16:20:30+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-18 21:15:47" itemprop="dateModified" datetime="2019-07-18T21:15:47+08:00">2019-07-18</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习/" itemprop="url" rel="index"><span itemprop="name">学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java监视器"><a href="#java监视器" class="headerlink" title="java监视器"></a>java监视器</h2><ul>
<li><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁” </p>
</li>
<li><p>在java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。<br>对于对象来说，相关联的监视器保护对象的实例变量。</p>
<p>对于类来说，监视器保护类的类变量。</p>
<p>（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视。）<br>为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。</p>
<p>但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）</p>
<p>类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。</p>
</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：<br>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。<br>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
</li>
<li><p>用法：</p>
<p>用于对象方法：synchronized  void fun(){}  对象锁</p>
<p>用于静态方法 :synchronized  static void fun(){} 类锁</p>
<p>用于代码段:synchronized （object） {}  对象锁</p>
</li>
<li><p>synchronized  即是对 对象 或 类 的监视器将代码锁定，<strong>锁的持有者是“线程”，而不是调用者</strong></p>
</li>
<li><p><strong>在Java中，synchronized不是可中断锁，而Lock是可中断锁。</strong> </p>
</li>
<li><p>java通过monitorenter和monitorex等java底层实现加锁，操作系统级别是利用Mutex Lock 来实现</p>
</li>
<li><p>java6之后增加了对 synchronized 的优化，增加：锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销。 </p>
</li>
<li><p>synchronized 是可重入的</p>
</li>
<li><p><strong>synchronized  保证可见性与原子性 但不保证指令重排</strong></p>
</li>
<li><p>由于等待一个锁定线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不需要锁的时候及时释放锁是很重要的。在以下情况下，持有锁的线程会释放锁：</p>
<ol>
<li><p>执行完同步代码块。</p>
</li>
<li><p>在执行同步代码块的过程中，遇到异常而导致线程终止。</p>
</li>
<li><p>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池。</p>
</li>
</ol>
</li>
</ul>
<p>除了以上情况外，只要持有锁的此案吃还没有执行完同步代码块，就不会释放锁。因此在以下情况下，线程不会释放锁：</p>
<ol start="4">
<li><p>在执行同步代码块的过程中，执行了Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。</p>
</li>
<li><p>在执行同步代码块的过程中，执行了Thread.yield()方法，当前线程放弃CPU，但不会释放锁。</p>
</li>
<li><p>在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类的suspend()方法已经被废弃。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2></li>
</ol>
<ul>
<li>volatile 关键字的作用<br><strong>保证内存的可见性</strong><br><strong>防止指令重排</strong><br><strong>注意：volatile 并不保证原子性</strong><br>内存可见性<br>volatile保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。<br>所以volatile关键字的作用之一就是保证变量修改的实时可见性。<br>当且仅当满足以下所有条件时，才应该使用volatile变量（常用于标志变量）<br><strong>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</strong><br><strong>该变量没有包含在具有其他变量的不变式中。</strong><br>volatile使用建议<br><strong>在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</strong><br>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键<br>字。<br>volatile和synchronized区别<br>volatile不会进行加锁操作：<br>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻<br>塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。<br> volatile 变量作用类似于同步变量读写操作：<br>从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码<br>块。<br>volatile 不如 synchronized安全：<br>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅<br>当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全<br>些。<br>volatile 无法同时保证内存可见性和原则性：<br>加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明<br>为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表<br>达式都不是原子操作：“count++”、“count = count+1”。</li>
<li>使用条件（都需要保证操作的原子性）：<ul>
<li>　　1）对变量的写操作不依赖于当前值 </li>
<li>　 2）该变量没有包含在具有其他变量的不变式中 </li>
</ul>
</li>
</ul>
<h2 id="显示锁lock"><a href="#显示锁lock" class="headerlink" title="显示锁lock"></a>显示锁lock</h2><ul>
<li><p>非java内置，Lock提供一个无条件的、可轮训的、定时的、可中断的锁获取操作。可通过此类实现同步访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reentrantlock 是Lock的一个实现。包含 可定时锁、可中断锁、公平锁。</p>
</li>
<li><p>AQS (AbstractQueuedSynchronizer) 同步器，主要是实现Reentrantlock及其他锁的底层重要同步器。</p>
<p>​    它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:getState()、setState()、compareAndSetState()。</p>
<p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>
<p>​    不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可.</p>
<p><img src="/imag%5Cjava%5CCH.png" alt></p>
<p>独占锁acquire()方法的执行流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: acquire入口</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">tryAcquire=&gt;condition: 获取同步状态</span><br><span class="line">addWaiter=&gt;operation: 新增节点并加入队列</span><br><span class="line">preIsHead=&gt;condition: 前驱节点是Head</span><br><span class="line">tryAcquire2=&gt;condition: 获取同步状态</span><br><span class="line">setHead=&gt;operation: 设置head节点为当前node</span><br><span class="line">wait=&gt;operation: 线程进入等待状态（阻塞）</span><br><span class="line">waitup=&gt;operation: 线程被唤醒</span><br><span class="line"></span><br><span class="line">st-&gt;tryAcquire</span><br><span class="line">tryAcquire(no)-&gt;addWaiter-&gt;preIsHead</span><br><span class="line">preIsHead(yes)-&gt;tryAcquire2</span><br><span class="line">preIsHead(no)-&gt;wait</span><br><span class="line">tryAcquire2(yes)-&gt;setHead(left)-&gt;e</span><br><span class="line">tryAcquire2(no)-&gt;wait(right)-&gt;waitup(right)-&gt;preIsHead</span><br><span class="line">tryAcquire(yes)-&gt;e</span><br></pre></td></tr></table></figure>

<p>​    release()操作将唤醒此节点的后节点，因此此AQS是FIFO队列。</p>
<p>​    以ReentrantLock为例(重写AQS的tryAcquire()等保护类型的方法)，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
</li>
</ul>
<h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><ul>
<li><p>java thread有五种状态类型<br>新建状态（New）：新创建了一个线程对象。<br>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>阻塞状态（Blocked）：塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。<br>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br>当我们调用线程类的sleep()、suspend()、yield()、wait()等方法时会导致线程进入阻塞状态。</p>
<p>   <strong>wait(): 调用任何对象的wait()方法会让当前线程进入等待，直到另一个线程调用同一个对象的    notify()或notifyAll()方法。</strong><br>notify():唤醒因调用这个对象wait()方法而阻塞的线程。</p>
</li>
<li><p><code>sleep()、suspend()、yield ()</code>等方法都隶属于 Thread 类，但<code>wait()/notify()</code>这一对却直接隶属于Object 类，也就是说，所有对象都拥有这一对方法。 </p>
</li>
<li><p>必须在 <code>synchronized</code>方法或块中调用 </p>
</li>
<li><p>使用 wait() 和notify()进行线程间通信</p>
</li>
</ul>
<h2 id="Threadlocal"><a href="#Threadlocal" class="headerlink" title="Threadlocal"></a>Threadlocal</h2><p>​    ThreadLocal 维护线程的局部变量，为每个线程提供一个可访问的副本。个线程变量之间可独立读写，没有联系和冲突。实现如下：</p>
<p>​    <img src="/imag%5Cjava%5C8100269-d4c18010361dc4e3.png" alt></p>
<p>​    Thread内部有一个 ThreadLocal.ThreadLocalMap 类型的Map，Map以 Threadlocal实例为key，value为变量值。线程内使用ThreadLocal获取本线程的副本变量时，实际是获取存储在Thread类里面的Map，此Map中以 此ThreadLocal为key的value值。ThreadLocal 与 key 是<strong>弱引用</strong>的关系，所以当ThreadLocal实例置null后，key也将在下次被 gc掉，但<strong>value不会被gc掉。这种情况可能会出现内存泄漏</strong>，java为最小化这种影响，在ThreadLocal的get、set的时候都会清除Map里所有key为null的value。</p>
<p>​    线程泄漏: 正常情况下,当线程对象被gc掉后,map中的value也会被gc 。 但当 使用线程池时，线程结束并不会被销毁，会再次使用，这时候容易出现内存泄漏。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><ul>
<li>锁顺序死锁</li>
<li>动态的锁顺序死锁</li>
<li>协作对象间的死锁</li>
<li>资源死锁</li>
</ul>
<h3 id="避免和诊断"><a href="#避免和诊断" class="headerlink" title="避免和诊断"></a>避免和诊断</h3><ul>
<li><p>确保锁顺序一致</p>
</li>
<li><p>开放调用</p>
<p>即<strong>调用某个外部方法时，不要持有锁。</strong></p>
</li>
<li><p>尝试定时的锁</p>
</li>
<li><p>通过线程转储分析</p>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>饥饿</li>
<li>活锁</li>
<li>弱响应</li>
</ul>
<h2 id="java存储模型"><a href="#java存储模型" class="headerlink" title="java存储模型"></a>java存储模型</h2><h2 id="比较并交换（Compare-and-swap-CAS）"><a href="#比较并交换（Compare-and-swap-CAS）" class="headerlink" title="比较并交换（Compare and swap, CAS）"></a>比较并交换（Compare and swap, CAS）</h2><p>​    现代处理器为并行处理提供的一个优化指令，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。其实CPU级别提供的一个原子指令，不用加锁，效率更高。</p>
<p>​    java中 <strong>sun.misc.Unsafe</strong> 实现了此方法，此类也在JUC（java.util.current）中如actomic类 大量使用，但官方不建议用户使用 sun.misc.Unsafe。因为 sun.misc.Unsafe 提供了可随意查看和修改JVM运行时的数据结构。</p>
<p>​    java代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">synchronized</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue ,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> oldValue = values;</span><br><span class="line">	<span class="keyword">if</span>(oldValue = expectValue)&#123;</span><br><span class="line">		value = newValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JVM对内部锁的优化"><a href="#JVM对内部锁的优化" class="headerlink" title="JVM对内部锁的优化"></a>JVM对内部锁的优化</h2><p>​    JDK1.6以后，出现了各种锁优化技术，如轻量级锁、偏向锁、适应性锁、锁粗化、锁消除等</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>​    分为两部分：1. Mark Word：存储对象自身的运行时数据，如：Hash Code，GC 分代年龄、锁信息。这部分数据在32位和64位的 JVM 中分别为 32bit 和 64bit；2. 存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数组的长度。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>核心思想：</strong>当线程请求到锁对象后，将锁对象的状态标志位改为 01，即偏向模式。然后使用 CAS 操作将线程的 ID 记录在锁对象的 Mark Word 中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</p>
<p><strong>与轻量级锁的区别：</strong>轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。</p>
<p><strong>作用：</strong>偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</p>
<p><strong>优点：</strong>偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>如果偏向锁失败，JVM 并不会立即挂起线程。他还会使用一种称为轻量级锁的优化手段。</p>
<p><strong>核心思想：</strong>轻量级锁将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区，如果获取轻量级锁失败，则表示其它线程先抢到了锁，那么线程的锁请求就会膨胀为重量级锁。</p>
<p><strong>前提：</strong>轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</p>
<p><strong>轻量级锁与重量级锁的比较：</strong></p>
<ul>
<li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；</li>
<li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>锁膨胀后，JVM 为避免线程真正在操作系统层面挂起，JVM 做了最后的努力 — 自旋锁。由于当前线程无法获取锁，但什么时候获取锁是一个未知数。</p>
<p>因此，系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁，JVM 让当前线程做几个空循环（这是自旋的含义）。在经过若干次循环后，如果可以得到锁，那么久顺利进入临界区。如果还不能获得锁，才会真正将线程在系统层面挂起。</p>
<p><strong>优点：</strong>由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；</p>
<p><strong>缺点：</strong>自旋等待过程线程一直占用 CPU 执行权但不处理任何任务，因此若该过程过长，那就会造成 CPU 资源的浪费。</p>
<p><strong>自适应自旋：</strong>自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是一种更彻底的锁优化，JVM 在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在的共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁的时间。</p>
<h2 id="用户锁优化"><a href="#用户锁优化" class="headerlink" title="用户锁优化"></a>用户锁优化</h2><ul>
<li>减少锁持有的时间</li>
<li>减小锁粒度</li>
<li>读写分离锁代理独占锁</li>
<li>锁分离</li>
<li>锁粗话 （针对平凡连续加锁行为，可进行锁粗化）</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/java并发编程实践(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/java并发编程实践(二)/" class="post-title-link" itemprop="url">java并发编程实践(二)---java 任务执行</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:20:20" itemprop="dateCreated datePublished" datetime="2019-06-24T16:20:20+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-18 21:03:45" itemprop="dateModified" datetime="2019-07-18T21:03:45+08:00">2019-07-18</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java线程创建方法"><a href="#java线程创建方法" class="headerlink" title="java线程创建方法"></a>java线程创建方法</h2><ul>
<li>实现Runnable</li>
<li>继承Thread</li>
<li>通过Callable 和 FutureTask<h2 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h2></li>
</ul>
<p>​    区别 ：一个带有返回值，一个不带返回值。共同点：用这个接口创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>​    Thread通过实现Runnanle接口，并通过本地方法创建线程。因为Thread调用start会创建启动一个新线程，所以 runnable的run()方法不会在主线程阻塞掉（在子线程中执行）而是继续执行。</p>
<p>Thread类的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">start()</td>
<td align="left">启动线程</td>
</tr>
<tr>
<td align="left">setName(String name)</td>
<td align="left">设置线程名称</td>
</tr>
<tr>
<td align="left">setPriority(int priority)</td>
<td align="left">设置线程优先级，默认5，取值1-10</td>
</tr>
<tr>
<td align="left">join(long millisec)</td>
<td align="left">挂起线程xx毫秒，等待线程结束</td>
</tr>
<tr>
<td align="left">interrupt()</td>
<td align="left">终止线程</td>
</tr>
<tr>
<td align="left">isAlive()</td>
<td align="left">测试线程是否处于活动状态</td>
</tr>
</tbody></table>
<p>Thread静态方法（实现全部通过本地方法）：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程。（即放弃此次的cpu，重新让CPU选择，可能是其他线程也可以是自己抢到）</td>
</tr>
<tr>
<td>sleep(long millisec)/sleep(long millis, int nanos)</td>
<td>挂起线程xx秒，参数不可省略</td>
</tr>
<tr>
<td>currentThread()</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td>holdsLock(Object x)</td>
<td>当前线程是否拥有锁</td>
</tr>
</tbody></table>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Executor就是Runnable和Callable的调度容器，<strong>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果</strong>、设置结果操作。get方法会阻塞，直到任务返回结果(<a href="http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm" target="_blank" rel="noopener">Future简介</a>)。Future声明如下 :</p>
<p>public interface Future<v> {</v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to cancel execution of this task.  This attempt will</span></span><br><span class="line"><span class="comment"> * fail if the task has already completed, has already been cancelled,</span></span><br><span class="line"><span class="comment"> * or could not be cancelled for some other reason. If successful,</span></span><br><span class="line"><span class="comment"> * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called,</span></span><br><span class="line"><span class="comment"> * this task should never run.  If the task has already started,</span></span><br><span class="line"><span class="comment"> * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines</span></span><br><span class="line"><span class="comment"> * whether the thread executing this task should be interrupted in</span></span><br><span class="line"><span class="comment"> * an attempt to stop the task.     *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed</span></span><br><span class="line"><span class="comment"> * normally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits if necessary for the computation to complete, and then</span></span><br><span class="line"><span class="comment"> * retrieves its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits if necessary for at most the given time for the computation</span></span><br><span class="line"><span class="comment"> * to complete, and then retrieves its result, if available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask则是一个RunnableFuture<v>，而RunnableFuture实现了Runnbale又实现了Futrue<v>这两个接口</v></v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>注：java 接口允许多继承，但不允许多实现。若在接口多继承中，父类有多个默认方法，则会强迫用户去override，否则报错。</em></p>
<p>##Excutor框架<br>​    Excutor框架提供 <strong>任务提交</strong>、和 <strong>任务执行</strong> 之间的解耦，这个框架可以用于异步任务执行，而且支持不同类型的任务执行策略。</p>
<p>![](/imag\java\executor uml.jpg)</p>
<h2 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>###构造参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory and rejected execution handler.</span></span><br><span class="line"><span class="comment"> * It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125; factory</span></span><br><span class="line"><span class="comment"> * methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h3><ol>
<li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p>
</li>
<li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p>
</li>
</ol>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”</li>
</ul>
<ol start="3">
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p>
</li>
<li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
</li>
</ol>
<p>顺序：<strong>新建线程 -&gt; 达到核心数 -&gt; 加入队列 -&gt; 新建线程（非核心） -&gt; 达到最大数 -&gt; 触发拒绝策略</strong></p>
<h3 id="拒绝策略（饱和策略）"><a href="#拒绝策略（饱和策略）" class="headerlink" title="拒绝策略（饱和策略）"></a>拒绝策略（饱和策略）</h3><h4 id="默认终止（abort）"><a href="#默认终止（abort）" class="headerlink" title="默认终止（abort）"></a>默认终止（abort）</h4><p>​    直接丢出异常RejectedExecutionException ，用户可捕获自行处理。线程池默认策略</p>
<h4 id="遗弃（discard）"><a href="#遗弃（discard）" class="headerlink" title="遗弃（discard）"></a>遗弃（discard）</h4><p>​    默认放弃这个任务，不抛出任何异常</p>
<h4 id="遗弃最旧的（discard-oldest）"><a href="#遗弃最旧的（discard-oldest）" class="headerlink" title="遗弃最旧的（discard-oldest）"></a>遗弃最旧的（discard-oldest）</h4><p>​    将消息队列中的第一个任务（最老未处理的）替换为当前新进来的任务执行。</p>
<h4 id="调用者运行（caller-runs）"><a href="#调用者运行（caller-runs）" class="headerlink" title="调用者运行（caller-runs）"></a>调用者运行（caller-runs）</h4><p>​    改策略既不会丢弃任务，也不会抛出任何异常。会把任务推到调用者线程里执行即在主线程中执行任务。若调用者线程即主线程已关闭，则丢弃</p>
<h3 id="其他一些内部方法："><a href="#其他一些内部方法：" class="headerlink" title="其他一些内部方法："></a>其他一些内部方法：</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>showdown()</td>
<td>使当前任务继续执行，不在添加新的task</td>
</tr>
<tr>
<td>shotdownNow()</td>
<td>停止当前正在运行的任务，返回未运行的任务</td>
</tr>
<tr>
<td>isShutdown()</td>
<td>当调用shotdown()后，此方法返回true</td>
</tr>
<tr>
<td>isTerminating()</td>
<td>正在关闭，但尚有未完全终止的任务，返回true</td>
</tr>
<tr>
<td>isTerminated()</td>
<td>是否完全关闭</td>
</tr>
<tr>
<td>awaitTermination(long timeout, TimeUnit unit)</td>
<td>多少时间之后去判断是否已终止工作</td>
</tr>
<tr>
<td>set/getRejectExecutionHandler()</td>
<td>设置任务被拒绝执行后的行为</td>
</tr>
<tr>
<td>prestartCoreThread()</td>
<td>开启一个核心线程</td>
</tr>
<tr>
<td>prestartAllCoreThreads()</td>
<td>启动全部的核心线程</td>
</tr>
<tr>
<td>getPoolSize()</td>
<td>取得池中现有的线程数</td>
</tr>
<tr>
<td>ensurePrestart()</td>
<td>确保至少有一个线程在运行（即使corePoolSize=0）</td>
</tr>
<tr>
<td>beforeExecutor、afterExecutor、terminated()</td>
<td>在任务开始/结束/线程池终止时，做的东西。其中任务开始/结束，是在子线程中执行，可能需要ThreadLocal或日志</td>
</tr>
<tr>
<td>其他一些get/set</td>
<td>一些其他参数的设置</td>
</tr>
</tbody></table>
<p>###PS:</p>
<p><strong>线程池中，里面的线程就会不间断的执行run方法，当执行完毕后再从任务队列去新的task去运行run。</strong></p>
<p><strong>若核心线程未满，但有线程空闲，新来任务会直接创建新的线程，不会加入空闲的线程里</strong></p>
<h3 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h3><p>​    通过继承ThreadPoolExecutor可以实现向线程池扩展一些功能，比如重写beforeExecutor 、afterExecutor和terminated可是加入一些日志和统计收集信息。</p>
<p><em>注：方法里面注意使用ThreadLocal或日志</em></p>
<h2 id="并行递归算法"><a href="#并行递归算法" class="headerlink" title="并行递归算法"></a>并行递归算法</h2><p>​    如果一个循环的每次迭代都是独立的，并且我们不必等待所有的迭代都完成后再一起处理，那么我们可以使用Executor把一个顺序执行的循环转化为并行的循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序执行</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processSequentially</span><span class="params">(List&lt;Element&gt; elements)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Element e:elements) &#123;</span><br><span class="line">           process(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//并行执行</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processInparallel</span><span class="params">(Executor executor,List&lt;Element&gt; elements)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">final</span> Element e:elements) &#123;</span><br><span class="line">           executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   process(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​    这同样适用于递归算法，可以将递归中每次递归交由线程池处理。例如二叉树的搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序递归</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sequentialRecursive</span><span class="params">(List&lt;Node&lt;Integer&gt;&gt; nodes, Collection&lt;Integer&gt; results)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;Integer&gt; node:nodes) &#123;</span><br><span class="line">           results.add(node.compute);<span class="comment">//任务计算</span></span><br><span class="line">           sequentialRecursive(nodes.getChildren(),results);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//并行递归</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor executor,List&lt;Node&lt;Integer&gt;&gt; nodes, Collection&lt;Integer&gt; results)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;Integer&gt; node:nodes) &#123;</span><br><span class="line">           executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   results.add(node.compute);<span class="comment">//任务计算</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           sequentialRecursive(nodes.getChildren(),results);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​        注：如需递归提前结束，程序中可加闭锁</p>
<h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><h3 id="volatile-域保存取消状态"><a href="#volatile-域保存取消状态" class="headerlink" title="volatile 域保存取消状态"></a>volatile 域保存取消状态</h3><ul>
<li><p>方法：增加一个volatile域的取消标志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> boolen cacelled</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!cacelled)&#123;</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优势：</p>
<p>设置简单，程序可以在已知被正确结束</p>
</li>
<li><p>缺点：</p>
<p>每次循环时判断，但程序可能在循环里阻塞掉，从而无法结束线程；循环体耗时过长无法快速结束</p>
</li>
</ul>
<h3 id="中断法"><a href="#中断法" class="headerlink" title="中断法"></a>中断法</h3><ul>
<li><p>方法：</p>
</li>
<li><p>特定阻塞库类的方法支持中断（sleep()）。每个线程中都有一个boolean类型的<strong>中断状态</strong>，在中断时，这个状态被置成 true。Thread.sleep 和 Object.wait ，都会试图去检测线程何时被中断，并提前返回，之后清除中断状态，抛出InterruptException。因此我们可在处理中断异常时结束线程。主线程通过调用线程中断来结束线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep();</span><br><span class="line">		...	</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优势：</p>
<p>线程会在合适的位置响应中断，不会立即中断正在运行的线程。处理中断时设置取消线程，<strong>这是取消线程的明智的选择</strong></p>
</li>
<li><p>缺点：只支持阻塞类库中方法响应中断，如Thread.sleep中才会响应中断，下面这种则不会理会中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  也不是所有的阻塞方法或阻塞机制都能响应中断；如果一个线程是由于进行同步Socket IO或者等待获得内部锁而阻塞的，那么除了能够设置线程的中断状态以外，什么都不能改变。对于那些不可中断的活动，这需要一些使用与中断类似的方法进行处理。</p>
<h3 id="致命要丸"><a href="#致命要丸" class="headerlink" title="致命要丸"></a>致命要丸</h3><ul>
<li><p>方法：一种保证生产者和消费者服务关闭的方式：一个可识别的对象。“当你得到就停止一切工作”。即在FIFO中，生产者当停止时向队列放入一个可识别对象，消费者消费到可识别对象后就关闭。此方式保证了消费者在关闭时已完成生产者关闭生产的数据。</p>
</li>
<li><p>缺点：这种只能在生产者消费者数量已知的情况下使用。</p>
</li>
</ul>
<h3 id="线程池关闭showdownNow"><a href="#线程池关闭showdownNow" class="headerlink" title="线程池关闭showdownNow"></a>线程池关闭showdownNow</h3><ul>
<li><p>方法：关闭线程池中正在执行的线程，返回未执行的线程。</p>
</li>
<li><p>缺点：无法得知那些已开始但未完成就关闭的线程。</p>
</li>
<li><p>改进：在线程池中的线程响应中断关闭时，保存那些响应中断而关闭的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exe;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCancelledAtShutdown = </span><br><span class="line"> 			Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Runnable&gt;());</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">TrackingExecutor</span><span class="params">(ExecutorService exec)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.exe = exec;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		exe.shutdown();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> exe.shutdownNow();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> exe.isShutdown();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> exe.isTerminated();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> exe.awaitTermination(timeout, unit);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line"> 		exe.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> 			</span><br><span class="line"> 			<span class="meta">@Override</span></span><br><span class="line"> 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 				<span class="keyword">try</span> &#123;</span><br><span class="line"> 					</span><br><span class="line"> 					runnable.run();</span><br><span class="line"> 				&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"> 					<span class="keyword">if</span> (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line"> 						tasksCancelledAtShutdown.add(runnable);<span class="comment">//将 取消正在执行的任务存放到set中</span></span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//获取取消的线程</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTask</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span> (!exe.isTerminated()) &#123;</span><br><span class="line"> 			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown);</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常线程与未捕获异常"><a href="#异常线程与未捕获异常" class="headerlink" title="异常线程与未捕获异常"></a>异常线程与未捕获异常</h3><p>​    jdk之前操控未捕获异常UncaughtException唯一方法就是子类话的ThreadGroup。在jdk5以后版本，可通过Thread.setUncaughtException来为每个线程设置一个UncaughtExceptionHandle来处理未捕获到的异常。JVM最终只会调用一个处理方法，优先级：每个线程的UncaughtExceptionHandle -&gt; ThreadGroup 的父级 -&gt; ThreadGroup -&gt; 控制台打印栈的追踪信息</p>
<h2 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h2><p>JVM关闭时将调用 所有注册的 Shutdown hook线程。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/java并发编程实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/java并发编程实践/" class="post-title-link" itemprop="url">java并发编程实践（一）</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:20:10" itemprop="dateCreated datePublished" datetime="2019-06-24T16:20:10+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-18 20:50:18" itemprop="dateModified" datetime="2019-07-18T20:50:18+08:00">2019-07-18</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基础知识</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>​    多核下的内存可见性，java的内存模型</p>
<p>​    产生原因：多处理器下，一个线程对某个变量的修改存于寄存器，未及时刷新到内存，则其他线程看不到已修改后的值；其他编译器的指令重排。</p>
<p>​    解决：同步机制，加锁或使用volatile 标识</p>
<h2 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h2><p>​    发布一个对象 意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有方法中返回这个引用或传递到其他地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Secrets</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Publishing an object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secrets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();  <span class="comment">// 多线程时 并不安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secret</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    逸出是指 一个对象在未准备好时就将它发布，这种情况成为逸出。以下就是个逸出，非线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnsafeStates</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * Allowing internal mutable state to escape</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">"AK"</span>, <span class="string">"AL"</span> <span class="comment">/*...*/</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    还有 this逸出：最好不要让ths在构造中逸出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThisEscape</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * Implicitly allowing the this reference to escape</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123; </span><br><span class="line">                doSomething(e); <span class="comment">// 这是初始化操作还未完全完成 会有未知问题发生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 其他初始化操作 这是其他初始化操作还未完成 但this已被其他线程使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventSource</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>​    共享的数据才会导致线程安全，因此线程封闭是实现线程安全的最简单的方式之一。Threadlocal和栈限制就是线程封闭的方法。</p>
<ul>
<li>Threalocal 会在每个线程保存一个副本，线程内使用自己副本，线程间不共享。<ul>
<li>栈限制中，只有本地变量才能触及对象。栈限制使得变量或对象只存于线程栈内，避免了数据共享。因此编程注意确保引用对象没有逸出。</li>
</ul>
</li>
</ul>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>​    <strong>不可变对象永远都是线程安全的。</strong></p>
<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>​    安全发布对象即意味着对象可被其他代码使用，线程安全</p>
<p>那我们怎么去安全发布对象呢？<br><strong>1.在静态初始化函数中初始化一个对象引用。</strong><br><strong>2.将对象的引用保存到volatile类型中或者AtomicReference对象中。</strong><br><strong>3.将对象的引用保存到某个正确构造对象的final类型域中。</strong><br><strong>4.将对象的引用保存到由一个锁保护的域中。</strong></p>
<p>一种使用volatile安全发布的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OneValueCache</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * Immutable holder for caching a number and its factors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VolatileCachedFactorizer</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * Caching the last result using a volatile reference to an immutable holder object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>​    原子操作即是不可切分的操作，了解原子操作可以避免对原子操作加锁造成的资源浪费，java中的原子操作包括：</p>
<p>​    1）除long和double之外的基本类型的赋值操作<br>​    2）所有引用reference的赋值操作<br>​    3）java.concurrent.Atomic.* 包中所有类的一切操作</p>
<p>​    <em>注：count++ 并不是原子操作</em></p>
<h2 id="实例限制"><a href="#实例限制" class="headerlink" title="实例限制"></a>实例限制</h2><p>​    通过确保对象只能被单一的线程访问（线程限制）或者确保所有的访问都正确地被锁保护。</p>
<p>​    良好实践：将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。把限制与各种适当的锁策略相结合，可以确保程序以线程安全的方式使用其他非线程安全对象。</p>
<p>​    如：类的每个方法上加synchronized （对实例加锁）可确保对象都是单一线程（确保内部数据不会逸出）。</p>
<h2 id="委托线程安全"><a href="#委托线程安全" class="headerlink" title="委托线程安全"></a>委托线程安全</h2><p>​    <strong>一些有线程安全的类组合成的组件或新类 不一定是线程安全的</strong></p>
<p>simpledateformat 非线程安全</p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>​    vector、hashtable</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>​    conuuentMap、CopyOnWriteList</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="Happens-before原则"><a href="#Happens-before原则" class="headerlink" title="Happens-before原则"></a>Happens-before原则</h2><p><strong>先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。</strong></p>
<p>先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到。</p>
<p>口诀：如果两个操作之间具有happen-before关系，那么前一个操作的结果就会对后面的一个操作可见。是Java内存模型中定义的两个操作之间的偏序关系。</p>
<p>常见的happen-before规则：</p>
<p>​    1.程序顺序规则：一个线程中的每个操作，happen-before在该线程中的任意后续操作。(注解：如果只有一个线程的操作，那么前一个操作的结果肯定会对后续的操作可见。)</p>
<p>​    2.锁规则：对一个锁的解锁，happen-before在随后对这个锁的加锁。(注解：这个最常见的就是synchronized方法和syncronized块)</p>
<p>​    3.volatile变量规则：<strong>对一个volatile域的写</strong>，happen-before在任意后续对这个volatile域的读。该规则在CurrentHashMap的读操作中不需要加锁有很好的体现。</p>
<p>​    4.传递性：如果A happen-before B，且B happen-before C，那么A happen - before C.</p>
<p>​    5.线程启动规则：Thread对象的start()方法happen-before此线程的每一个动作。</p>
<p>​    6.线程终止规则：线程的所有操作都happen-before对此线程的终止检测，可以通过Thread.join()方法结束，Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p>
<p>​    7.线程中断规则：对线程interrupt()方法的调用happen-before发生于被中断线程的代码检测到中断时事件的发生。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/hadoop 安装指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/hadoop 安装指南/" class="post-title-link" itemprop="url">hadoop 安装指南</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:18:55" itemprop="dateCreated datePublished" datetime="2019-06-24T16:18:55+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 21:42:49" itemprop="dateModified" datetime="2019-07-09T21:42:49+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://archive.apache.org/dist/hadoop/core/hadoop-1.2.1/hadoop-1.2.1.tar.gz" target="_blank" rel="noopener">https://archive.apache.org/dist/hadoop/core/hadoop-1.2.1/hadoop-1.2.1.tar.gz</a></p>
<p>##配置集群间免密登录</p>
<p>192.168.0.201   master<br>192.168.0.202   worker2<br>192.168.0.203   worker3</p>
<p>##配置</p>
<p>修改conf/core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- file system properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://192.168.0.201:49000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.checkpoint.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/dfs/namesecondary<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1）fs.default.name是NameNode的URI。hdfs://主机名:端口/<br>2）hadoop.tmp.dir ：Hadoop的默认临时路径，这个最好配置，如果在新增节点或者其他情况下莫名其妙的DataNode启动不了，就删除此文件中的tmp目录即可。不过如果删除了NameNode机器的此目录，那么就需要重新执行NameNode格式化的命令。</p>
<p>修改conf/mapred-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.0.201:49001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.local.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/var<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.intermediate-done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/mr-history/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/mr-history/done<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改conf/hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>name node dir<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop_dir/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1）   dfs.name.dir是NameNode持久存储名字空间及事务日志的本地文件系统路径。 当这个值是一个逗号分割的目录列表时，nametable数据将会被复制到所有目录中做冗余备份。  2）   dfs.data.dir是DataNode存放块数据的本地文件系统路径，逗号分割的列表。 当这个值是逗号分割的目录列表时，数据将被存储在所有目录下，通常分布在不同设备上。  3）dfs.replication是数据需要备份的数量，默认是3，如果此数大于集群的机器数会出错。 </p>
<p>编辑conf/master<br>master</p>
<p>编辑conf/slaver<br>worker2<br>worker3</p>
<p>修改hadoop-env.sh<br>/# export JAVA_HOME=/usr/lib/jvm/java-6-sun<br>去掉#好 改成真实路径 JAVA_HOME=/opt/java/jdk1.8.0_172</p>
<p>##开始&amp;结束</p>
<p>第一次先格式化<br>bin/hadoop namenode -format</p>
<p>./bin/start-all.sh<br>./bin/stop-all.sh</p>
<p>web监视界面<br><a href="http://192.168.0.201:50030" target="_blank" rel="noopener">http://192.168.0.201:50030</a><br><a href="http://192.168.0.201:50070" target="_blank" rel="noopener">http://192.168.0.201:50070</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Redis 笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/Redis 笔记/" class="post-title-link" itemprop="url">Redis 笔记----《Redis设计与实现》</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:18:55" itemprop="dateCreated datePublished" datetime="2019-06-24T16:18:55+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 21:40:58" itemprop="dateModified" datetime="2019-07-09T21:40:58+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    </p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><ul>
<li><p>SDS</p>
<ul>
<li>动态字符串</li>
<li><img src="C:%5CUsers%5Czlk%5CAppData%5CLocal%5CTemp%5C1557408076819.png" alt="1557408076819"></li>
</ul>
</li>
<li><p>链表</p>
</li>
<li><p>字典</p>
<ul>
<li><img src="C:%5CUsers%5Czlk%5CAppData%5CLocal%5CTemp%5C1557408278904.png" alt="1557408278904"></li>
<li>ht[1]是在rehash时使用</li>
</ul>
</li>
<li><p>SkipList跳表</p>
<ul>
<li><img src="C:%5CUsers%5Czlk%5CAppData%5CLocal%5CTemp%5C1557408331278.png" alt="1557408331278"></li>
</ul>
</li>
<li><p>整数集合</p>
<ul>
<li><img src="C:%5CUsers%5Czlk%5CAppData%5CLocal%5CTemp%5C1557408357317.png" alt="1557408357317"></li>
<li>可自动升级，不可降级</li>
</ul>
</li>
<li><p>压缩列表</p>
</li>
<li><p>对象</p>
<ul>
<li>引用计数内存回收</li>
<li>对象共享<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2></li>
</ul>
</li>
<li><p>RDB 持久化内存中的键值对</p>
</li>
<li><p>AOF（Append Only File） 记录操作命令</p>
<h2 id="复制与集群"><a href="#复制与集群" class="headerlink" title="复制与集群"></a>复制与集群</h2></li>
<li><p>复制 </p>
<p>主从复制</p>
</li>
<li><p>集群</p>
<p>一致性哈希 ，分配16384曹，客户端 key-value 命令 根据key (CRC-16 &amp; 16383) 找到所负责槽的节点执行。</p>
<h2 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h2></li>
<li><p>发布订阅</p>
</li>
<li><p>事物</p>
</li>
<li><p>Lua Script</p>
</li>
<li><p>排序</p>
</li>
<li><p>二进制位数组</p>
</li>
<li><p>慢查询日志</p>
</li>
<li><p>监视器</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/Java/" class="post-title-link" itemprop="url">Java  笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:18:55" itemprop="dateCreated datePublished" datetime="2019-06-24T16:18:55+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 21:39:14" itemprop="dateModified" datetime="2019-07-09T21:39:14+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##基本类型</p>
<p>###Integer<br>    Max 0x7fffffff<br>    Min 0x80000000<br>    最大转化的进制可能的字符：<br>    final static char[] digits = {<br>        ‘0’ , ‘1’ , ‘2’ , ‘3’ , ‘4’ , ‘5’ ,<br>        ‘6’ , ‘7’ , ‘8’ , ‘9’ , ‘a’ , ‘b’ ,<br>        ‘c’ , ‘d’ , ‘e’ , ‘f’ , ‘g’ , ‘h’ ,<br>        ‘i’ , ‘j’ , ‘k’ , ‘l’ , ‘m’ , ‘n’ ,<br>        ‘o’ , ‘p’ , ‘q’ , ‘r’ , ‘s’ , ‘t’ ,<br>        ‘u’ , ‘v’ , ‘w’ , ‘x’ , ‘y’ , ‘z’<br>    };<br>    方法：包含进制转换<br>    int 类型转无符号：用long扩展表示int的无符号数 ((long) x) &amp; 0xffffffffL;<br>-<strong>java中有三种移位运算符</strong></p>
<p>&lt;&lt; : 左移运算符，num &lt;&lt; 1,相当于num乘以2</p>
<p>&gt;&gt; :   右移运算符，num &gt;&gt; 1,相当于num除以2</p>
<p>&gt;&gt;&gt;    :     无符号右移，忽略符号位，空位都以0补齐</p>
<p>**int numberOfLeadingZeros(int i): 得到从左边起多少个零 源码：<br>// HD, Figure 5-6<br>        if (i == 0)<br>            return 32;<br>        int n = 1;<br>        if (i &gt;&gt;&gt; 16 == 0) { n += 16; i &lt;&lt;= 16; }<br>        if (i &gt;&gt;&gt; 24 == 0) { n +=  8; i &lt;&lt;=  8; }<br>        if (i &gt;&gt;&gt; 28 == 0) { n +=  4; i &lt;&lt;=  4; }<br>        if (i &gt;&gt;&gt; 30 == 0) { n +=  2; i &lt;&lt;=  2; }<br>        n -= i &gt;&gt;&gt; 31;<br>        return n;<br>来自《Hacker’s Delight》这本书</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Assignment 3 Steganography/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/Assignment 3 Steganography/" class="post-title-link" itemprop="url">Assignment 3 Steganography</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:18:55" itemprop="dateCreated datePublished" datetime="2019-06-24T16:18:55+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 21:21:34" itemprop="dateModified" datetime="2019-07-09T21:21:34+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><a href="https://en.wikipedia.org/wiki/Steganography" target="_blank" rel="noopener">Steganography</a> refers to hiding information such as text/images/data within another file/message/data with the intent of concealing the existence of the hidden information. A common method for this is hiding data within the least significant bits of the bytes representing colours in an image. The LSB can be represented as 0b00000001, 0x01 or 1 and the MSB can be represented as 0b10000000, 0x80 or 128.</p>
<p>You are to write a program that can be used to hide data from a supplied file in the low bits of a supplied image file. The same program will also be able to check the size of hidden data, extract the data and verify, using a checksum, the integrity of the hidden data in an image.</p>
<h1 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h1><p><img src="https://static.edusercontent.com/files/umhGWvrf2BLnbt07JkWexXQv" alt="img"></p>
<p>Bitmap files (<code>*.bmp</code>) are a relatively simple file format. The file consists of a header containing metadata about the pixel format and image size and is <code>m</code> bytes long. The pixel data follows in the remaining <code>l</code> bytes, the size of which can be calculated from the information in the header. The basic specification only requires you handle these files and a <code>bitmap</code> module is supplied to assist in getting the length of the header in bytes and the length of the pixel data in bytes.</p>
<p><img src="https://static.edusercontent.com/files/MzqCKX0tcwNytFX6U81xDaIs" alt="img"></p>
<p>The program shall only modify the data relating to pixel bytes and shall copy the header information required for the image file format without modification. Concealing a single byte within the pixel data is depicted in the above diagram. The MSB of concealed data shall be placed in lower index pixel bytes and the LSB in higher index pixel bytes. Where multiple bits are concealed per byte of pixel data (as in a following diagram) the more significant bits of concealed data shall be placed in more significant bits of the pixel byte. Where there are insufficient bits of the current byte of concealed data to fill the required number of bits in the pixel byte the most significant bit(s) of the next byte of concealed data shall be utilised.</p>
<p>The format of the concealed data consists of a 32 bit unsigned integer giving the length of the data payload, the data payload and a 32 bit unsigned integer checksum of the data payload. The data length and checksum parameters are always encoded as 1 concealed bit per byte of pixel data. The concealed data is encoded as the minimum number of concealed bits per byte of pixel data to completely encode the payload. This may require 2, 3 or even 8 bits concealed per byte of pixel data. Where multiple bits are required per byte more significant bits of concealed data are encoded in the more significant bits of the pixel data as shown in a following diagram where concealing 3 bits per byte of pixel data is depicted. Once all the bytes of the data payload have been concealed remaining bits in the current pixel byte shall be set to 0 and remaining pixel bytes (until the last 32 bytes for the checksum) shall be copied unmodified.</p>
<p><img src="https://static.edusercontent.com/files/G2ZRyBfgTu3fVIwAWPVJNgSJ" alt="img"></p>
<p>Given <code>o</code> bytes of data to conceal the <em>output</em> image file that has <code>l</code> bytes of pixel data shall have:</p>
<ol>
<li><code>m</code> bytes of header data directly copied from the <em>input</em> source image file. </li>
<li>32 bytes of pixel data with the length of the data payload <code>o</code> concealed 1 bit per byte.</li>
<li><code>p</code> bytes of modified pixel data<ol>
<li><code>r</code> bits of concealed data per pixel byte shall be used where,</li>
<li>r is the minimum number of bits per pixel such that the concealed data can fit within the available pixel values.</li>
<li>r is an integer value such that the following is true <code>(r - 1) * (l - 64) &lt; (o * 8) &amp;&amp; r * (l - 64) &gt;= (o * 8)</code></li>
<li>If (<code>r * p) != (o * 8)</code> the ‘concealed’ bits will be append with <code>s</code> ‘0’ bits such that <code>(r * p) == (s + o * 8)</code>.</li>
</ol>
</li>
<li><code>q</code> bytes of unmodified pixel data.</li>
<li>32 bytes of pixel data with the checksum of the data payload concealed 1 bit per byte.</li>
</ol>
<p><img src="https://static.edusercontent.com/files/nptFahhlPgsye67hOWnm7XXO" alt="img"></p>
<p>Once all the concealed data is encoded the remaining bytes are copied unmodified until the checksum. If at the end of the concealed data there are insufficient bits to fill the last pixel byte (as in the above diagram) the remaining bits shall be set to 0.</p>
<h1 id="Basic-Specification-75"><a href="#Basic-Specification-75" class="headerlink" title="Basic Specification (75%)"></a>Basic Specification (75%)</h1><p>The program shall comply with the following specification:</p>
<h2 id="1-Compilation-amp-Code"><a href="#1-Compilation-amp-Code" class="headerlink" title="1. Compilation &amp; Code"></a>1. Compilation &amp; Code</h2><ol>
<li>The program shall be written in C and compiled with GCC using the C11 standard; the compiled executable shall be named <code>steg</code>. Compilation flags shall include “<code>-Wall -Wextra -Wpedantic -fsanitize=address -std=c11</code>“. Additional flags that do not remove/undo the effects of these flags shall be permitted.</li>
<li>Compilation shall be through a <code>Makefile</code> that has <code>steg</code> and <code>clean</code> as targets.</li>
<li>All comments in the source code shall be written in English.</li>
</ol>
<h2 id="2-Error-Handling"><a href="#2-Error-Handling" class="headerlink" title="2. Error Handling"></a>2. Error Handling</h2><ol>
<li>All error messages, which are messages starting with “Error:”, shall be printed to the terminal using <code>stderr</code>.</li>
<li>Where the specification states “exit immediately with error code n” this is to mean no further text shall be printed to the terminal and the return statement in <code>main</code> shall return <code>n</code>. All allocated memory shall be properly freed.</li>
<li>Errors shall be responded to in the following order:<ol>
<li>Left to right for command line options.</li>
<li>Missing input files before existing output files.</li>
<li>Payload size relative to image size.</li>
<li>Checksum verification.</li>
</ol>
</li>
<li>If no errors occur the program shall return an error code of 0.</li>
</ol>
<h2 id="3-Command-Line-Options"><a href="#3-Command-Line-Options" class="headerlink" title="3. Command Line Options"></a>3. Command Line Options</h2><ol>
<li><p>The program will accept 1, 2 or 3 non-option arguments (arguments after and including the first argument that doesn’t start with <code>-</code>). The following points specify the differing behaviour of the program with each number of arguments.</p>
</li>
<li><p>Optional arguments may modify the behaviour of the program and shall be given before any non-option arguments.</p>
</li>
<li><p>If the program is given zero non-option arguments it shall print <code>Error: No file name provided.\n</code> and exit immediately with error code 7.</p>
</li>
<li><p>If the program is given more than three non-option arguments it shall print <code>Error: Too many file names provided.\n</code> and exit immediately with error code 6.</p>
</li>
<li><p>If the program is given three non-option arguments it shall treat the first non-option argument as the name of an <em>input</em> source image file, the second non-option argument as the name of an <em>input</em> source data file and the third non-option argument as the name of an <em>output</em> destination image file. It shall then embed the contents of the input source data file in the input source image pixels and output to the destination image file the modified pixel values and unmodified file format/header information.</p>
</li>
<li><p>If the program is given two non-option arguments it shall treat the first non-option argument as an <em>input</em> image file with encoded data and the second non-option argument as an <em>output</em> data file. It shall then extract the contents of the input image file to the output data file.</p>
</li>
<li><p>If the program is given one non-option argument it shall treat it as an <em>input</em> image file with encoded data and only decode if another option is specified.</p>
</li>
<li><p>The program shall accept the optional argument <code>-h</code> which shall cause the program to print the specified help message and immediately exit with error code 1. The help message is:</p>
<p>Text</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Usage: steg [-vncp] source_image [[data_file] [output_image]]</span><br><span class="line"></span><br><span class="line">Steganographically conceal/extract data from an image.</span><br><span class="line"> </span><br><span class="line">With three arguments will conceal data from data_file within source_image and</span><br><span class="line"> </span><br><span class="line">output to output_image. One and two argument versions inspect (and optionally save)</span><br><span class="line"> </span><br><span class="line">data from an image with concealed data.</span><br><span class="line"></span><br><span class="line">  -c  Print the checksum of the concealed data.</span><br><span class="line"> </span><br><span class="line">  -h  Print this help message.</span><br><span class="line"> </span><br><span class="line">  -n  Print the number of concealed bytes.</span><br><span class="line"></span><br><span class="line">  -p  Print the contents of a concealed image/data file when concealing. Assuming text data.</span><br><span class="line"> </span><br><span class="line">  -v  Verify checksum of an image with concealed data. Invalid if an output image is specified.</span><br></pre></td></tr></table></figure>



<ol start="9">
<li><p>The program shall accept the optional argument <code>-n</code> which shall cause the program to print the length of hidden data in bytes, in the format <code>Hidden data length: 45643 bytes.\n</code>.</p>
</li>
<li><p>The program shall accept the optional argument <code>-c</code> which shall cause the program to print the checksum of the hidden data as a 32-bit hex number in the format <code>Checksum: 0x0400F50F.\n</code>. When the <em>input</em> image contains hidden data, as signified by a command line containing 1 or 2 non-option arguments, this checksum value shall be read from the stored checksum. When creating an <em>output</em> image containing hidden data the checksum value printed shall be checksum calculated from the <em>input</em> data.</p>
</li>
<li><p>The program shall accept the option argument <code>-p</code> which shall cause the program to print the hidden data (treating it as a text file/string) between two lines that each consist of 80 hyphens:</p>
</li>
</ol>
<pre><code>Text
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">This is the contents of a text file. The first line was very long and did not end at 80 characters.</span><br><span class="line"></span><br><span class="line">This file ended with a new line character and means there is a blank line before the hyphens.</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></code></pre><ol start="12">
<li><p>The program shall accept the optional argument <code>-v</code> which shall cause the program to verify the checksum with the data. The <code>-v</code> optional argument shall be valid only with one and two non-option argument invocations of the program. If the optional argument <code>-v</code>Iis used with the three non-option argument invocation of the program the program shall print <code>Error: -v invalid when concealing data.\n</code> and exit immediately with error code 11. If the calculated checksum differs from the stored checksum the program shall print <code>Error: Checksum mismatch.\n</code> and exit immediately with error code 12. If the calculated checksum matches the stored checksum the program shall print <code>Checksums match.\n</code>. </p>
</li>
<li><p>If the program finds an optional argument that it is not known it shall print <code>Error: Unknown option -%s.\n</code> and immediately exit with error code 8.</p>
</li>
<li><p>Output/effects from processing optional arguments shall occur after any output files have been written and will occur in the order <code>-p</code>, <code>-n</code>, <code>-c</code>, <code>-v</code>.</p>
</li>
</ol>
<h2 id="4-File-Handling"><a href="#4-File-Handling" class="headerlink" title="4. File Handling"></a>4. File Handling</h2><ol>
<li>If a nominated <em>input</em> file does not exist the program shall print an error message <code>Error: Input file %s was not found.\n</code> and exit immediately with error code 2. The token  <code>%s</code> shall be replaced with the name of the file that was nominated.</li>
<li>If a nominated <em>output</em> file exists the program shall inquire of the user <code>Output file %s already exists. Overwrite (y/n)?</code>  If an affirmative answer (<code>y, yes</code> - case insensitive) is received, the program shall continue and overwrite the file. If the answer is negative (<code>n, no</code> - case insensitive) the program shall emit no further messages and exit immediately with error code 3. If any other value is received the program shall ask the question again.</li>
<li>If the data to be encoded cannot fit within the source image pixel values (see encoding details above) the program shall print <code>Error: Input data too large to hide within source image.\n</code> and exit immediately with error code 5.</li>
<li>If when attempting to decode an <em>input</em> image file the decoded data size is too large to be concealed within the image file the program shall print an error message <code>Error: Image file too small to conceal %i bytes of data.\n</code> and exit immediately with error code 9.</li>
</ol>
<h2 id="5-Checksum"><a href="#5-Checksum" class="headerlink" title="5. Checksum"></a>5. Checksum</h2><p>A <a href="https://en.wikipedia.org/wiki/Checksum" target="_blank" rel="noopener">checksum</a> is a method to check if data has been modified or changed. It is a function of the data and is generally sensitive to changes of a single bit. As we are storing data within an image we need a way to verify that it has not been corrupted in an image editing program. To this end we have devised a relatively simple checksum to use.</p>
<ol>
<li>The data payload shall be broken into 16-bit unsigned short integers using <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">little endian</a> ordering.</li>
<li>Each short shall be squared (multiplied by itself) and the result stored in an unsigned integer (32-bit).</li>
<li>The result of the squaring operation shall be successively XOR’d (<code>^</code> operator) to get the final checksum.</li>
<li>If the data payload has an odd number of bytes an additional zero byte shall be appended onto the end for the purposes of calculating the checksum but shall not be stored/concealed within the pixel bytes.</li>
</ol>
<h1 id="Code-Quality-25"><a href="#Code-Quality-25" class="headerlink" title="Code Quality (25%)"></a>Code Quality (25%)</h1><p>A quarter of your mark will be based on code quality. This includes consistent and clear formatting, sensible variable and function names (self-documenting), succinct, clear and appropriate comments as well as cohesive module design, correct usage of headers and control structures (switch, if-else if-else, while, for).</p>
<h1 id="Extension-Bonus-10"><a href="#Extension-Bonus-10" class="headerlink" title="Extension (Bonus 10%)"></a>Extension (Bonus 10%)</h1><p>We are adding a <strong>difficult</strong> bonus extension to this project. It is not expected that many will be able to complete this but is posed as a challenge. Instead of handling only bitmaps your program shall also accept png image files. Png is another image format that has lossless compression. An open source library is available to assist with parsing and accessing the data (<code>libpng</code>). This extension will involve recognising the image format from the extension of the filename (png vs bmp). We won’t ask you to convert between formats (input image format will match the output format).</p>
<p>No assistance will be provided in the use of <code>libpng</code> so that you will have to rely on reading the documentation which is available online at the libpng <a href="http://www.libpng.org/pub/png/libpng.html" target="_blank" rel="noopener">website</a>.</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ol>
<li>All images provided will be valid bitmaps and the supplied bitmap files <code>bitmap.h</code> and <code>bitmap.o</code> will be able to give the lengths of header and pixel data reliably.</li>
<li>Although <code>getopt</code> can handle splitting <code>-pnc</code> to <code>-p -n -c</code> we will not be testing this. We will test:<ol>
<li>Other optional arguments like <code>-x</code></li>
<li>Too many/too few non-option arguments.</li>
</ol>
</li>
</ol>
<h1 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h1><ol>
<li><p>Command line parsing without <code>getopt</code> will be difficult.</p>
</li>
<li><p>Encoding a single bit per byte is significantly easier than the general case.</p>
</li>
<li><p>Two bits per byte is still significantly easier than the general case as well.</p>
</li>
<li><p><code>fopen</code> has enhanced handling for cases when files exist in C11.</p>
</li>
<li><p>When creating your <code>Makefile</code> be careful not to delete the supplied <code>bitmap.o</code>. If you do another one copy can be obtained here.</p>
<p><a href="https://static.edusercontent.com/files/hvsCDqP69yWYTvOp4snB7NeY" target="_blank" rel="noopener">bitmap.o</a></p>
</li>
<li><p>Be careful you encode/decode bits in the specified order. We are checking for exact matches in the encoded images.</p>
</li>
<li><p>You can manually inspect the contents (byte by byte) of files using the <code>xxd</code> program. For example, <code>xxd -l len -b filename</code> will display ‘len’ bytes of the file named ‘filename’, in binary format.</p>
</li>
</ol>
<h1 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h1><ol>
<li>Your submission must include a <code>Makefile</code> that you shall provide. You can use a previously supplied <code>Makefile</code> as a template and adapt it to this assignment or write your own less generic <code>Makefile</code> based on the lecture slides.</li>
<li>The executable that is created shall be called <code>steg</code>. It shall be created in the root directory of your submission.</li>
<li>Your code shall be compiled by executing the command <code>make clean &amp;&amp; make</code> in the root directory of your submission. This shall delete all intermediate object files (except <code>bitmap.o</code>) and build the <code>steg</code> program.</li>
</ol>
<h1 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h1><p>You may use any function in the C11 standard library. You additionally may use the <code>getopt</code> function from the GNU C Library (found in header <code>getopt.h</code>). We also supply files  <code>bitmap.o</code> and <code>bitmap.h</code> that enable parsing of bitmaps to get the length of the bitmap header and size of pixel data. If attempting the png extension you may additionally utilise <code>libpng</code> which is already available within edstem.</p>
<p>The following library functions are likely to be useful:</p>
<p>Header <strong>&lt;stdio.h&gt;</strong> has file input/output functions: <strong>fread(), fwrite(), fopen(), fseek(), fclose()</strong><br>Header <strong>&lt;getopt.h&gt;</strong> has argument parsing function: <strong>getopt()</strong><br>Header <strong>&lt;assert.h&gt;</strong> has the bug-catching macro: <strong>assert()</strong></p>
<h1 id="Expectations"><a href="#Expectations" class="headerlink" title="Expectations"></a>Expectations</h1><ul>
<li>This is an individual assignment, not group work. Although you can consult others about the use of specific functions, the code that you submit must be solely your own work: The result of your thought processes, design decisions, implementation and testing.</li>
<li>We expect you to follow good design practices, including the use of functions to reduce complexity and code repetition.</li>
<li>You will make completing the assignment significantly easier if you start work on it early and adopt an incremental approach to implementation and testing. In other words, <ul>
<li>Do not code the entire program and then submit it for testing. Instead, code a small subsection and test it, then incrementally extend this subsection and re-test.</li>
<li>Do not submit your first code at 10pm on the night that the assignment is due and expect everything to work…</li>
</ul>
</li>
<li>Avoid submitting just before it is due - clock synchronisation or build times may shift your final submission to microseconds after the cutoff 11:59:00PM and result in late penalties.</li>
<li>Elements of the project are intended to be challenging. The extension in particular is designed to challenge the most skilled amongst you.</li>
</ul>
<h1 id="Academic-Honesty"><a href="#Academic-Honesty" class="headerlink" title="Academic Honesty"></a>Academic Honesty</h1><p>While the University is aware that the vast majority of students and staff act ethically and honestly, it is opposed to and will not tolerate academic dishonesty or plagiarism and will treat all allegations of dishonesty seriously.</p>
<p>Further information on academic honesty, academic dishonesty, and the resources available to all students can be found on the academic integrity pages on the current students website:</p>
<p><a href="https://sydney.edu.au/students/academic-integrity.html" target="_blank" rel="noopener">https://sydney.edu.au/students/academic-integrity.html</a>. </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Cassandra 教程（2）——系统启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zlksilence">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/headpiture.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silence">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/Cassandra 教程（2）——系统启动流程/" class="post-title-link" itemprop="url">Cassandra 教程（2）——系统启动流程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:18:55" itemprop="dateCreated datePublished" datetime="2019-06-24T16:18:55+08:00">2019-06-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 21:38:22" itemprop="dateModified" datetime="2019-07-09T21:38:22+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="程序入口："><a href="#程序入口：" class="headerlink" title="程序入口："></a>程序入口：</h2><h3 id="初始化构造函数"><a href="#初始化构造函数" class="headerlink" title="初始化构造函数"></a>初始化构造函数</h3><p>上节可知程序入口为：org.apache.cassandra.service.CassandraDaemon</p>
<p>此主类使用的单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CassandraDaemon instance = <span class="keyword">new</span> CassandraDaemon();</span><br></pre></td></tr></table></figure>

<p>CassanDaemon 首先创建一个自己的实例。构造函数只进行了一些运行前的环境检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CassandraDaemon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CassandraDaemon</span><span class="params">(<span class="keyword">boolean</span> runManaged)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.runManaged = runManaged;</span><br><span class="line">     <span class="keyword">this</span>.startupChecks = <span class="keyword">new</span> StartupChecks().withDefaultTests();</span><br><span class="line">     <span class="keyword">this</span>.setupCompleted = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="main函数运行"><a href="#main函数运行" class="headerlink" title="main函数运行"></a>main函数运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      instance.activate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>main中通过调用<code>activate()</code>进行读取配置参数、初始化JMX等</p>
<h4 id="读取配置参数"><a href="#读取配置参数" class="headerlink" title="读取配置参数"></a>读取配置参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行参数初始化 结果保存在DatabaseDescriptor里</span></span><br><span class="line"> DatabaseDescriptor.daemonInitialization();</span><br></pre></td></tr></table></figure>

<p>DatabaseDescriptor 中保存有所有的配置参数及其对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseDescriptor</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> IEndpointSnitch snitch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetAddress listenAddress; <span class="comment">// leave null so we can fall through to getLocalHost</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetAddress broadcastAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetAddress rpcAddress;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>org.apache.cassandra.config 囊括了所有与配置参数有关的类，结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//cassandra.config 之前在VM optionts中指定了配置文件路径</span></span><br><span class="line"> String configUrl = System.getProperty(<span class="string">"cassandra.config"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/headpiture.jpg" alt="zlksilence">
            
              <p class="site-author-name" itemprop="name">zlksilence</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zlksilence" title="GitHub &rarr; https://github.com/zlksilence" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:zksilence@gmail.com" title="E-Mail &rarr; mailto:zksilence@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zlksilence</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
